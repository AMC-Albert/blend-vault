"""
Content building utilities for Blend Vault.
Handles building sidecar markdown content from collected data.
"""

import bpy  # type: ignore
import os
import json
import re
from typing import Dict, List, Tuple
from ..utils import (
	generate_filepath_hash,  # Renamed from ensure_library_hash
	get_resource_warning_prefix,
	SIDECAR_EXTENSION,
	BV_UUID_PROP,
	BV_FILE_UUID_KEY,
	format_primary_link
)
from ..preferences import get_obsidian_vault_root
from .uuid_manager import read_sidecar_uuid


def build_sidecar_content(
	blend_path: str, 
	local_assets: Dict, 
	linked_assets_by_library: Dict,
	resources: List[dict]
) -> Tuple[str, Dict]:
	"""Build sidecar content and track UUID pushes."""
	file_uuid = read_sidecar_uuid(blend_path + SIDECAR_EXTENSION) or generate_filepath_hash(blend_path)
	# Build content sections
	blend_filename = os.path.basename(blend_path)
	sections = [
		"## %% Blend Vault Data",
		"This section is auto-generated by the Blend Vault plugin and will be overwritten on save. User content can be added above this heading.",
		"### " + format_primary_link("./" + blend_filename, "Current File"),
		"```json",
		json.dumps({
			"path": os.path.basename(blend_path),
			BV_FILE_UUID_KEY: file_uuid,
			"assets": list(local_assets.values())
		}, indent=2, ensure_ascii=False),
		"```",
		"### Linked Libraries"
	]
	
	# Add linked libraries section
	uuid_pushes = {}
	libraries = list(bpy.data.libraries)
	
	if not libraries:
		sections.append("- None")
	else:
		uuid_pushes = _build_linked_libraries_section(sections, libraries, blend_path, linked_assets_by_library)
	
	# Add resources section
	_build_resources_section(sections, resources, blend_path)
	
	return "\n".join(sections) + "\n", uuid_pushes


def _build_linked_libraries_section(
	sections: List[str], 
	libraries: List, 
	blend_path: str, 
	linked_assets_by_library: Dict
) -> Dict:
	"""Build the linked libraries section and return UUID pushes."""
	uuid_pushes = {}
	for lib in libraries:
		# Process library path
		lib_path = lib.filepath.lstrip('//').replace('\\', '/')
		# Ensure lib_path doesn't already have sidecar extension
		if lib_path.endswith(SIDECAR_EXTENSION):
			lib_path = lib_path[:-len(SIDECAR_EXTENSION)]
		
		# Keep the library sidecar path relative for local path resolution
		# but use absolute path for file existence checking
		lib_sidecar_path = os.path.normpath(
			os.path.join(os.path.dirname(blend_path), lib_path)
		) + SIDECAR_EXTENSION
		
		# Get or generate library UUID
		lib_uuid = read_sidecar_uuid(lib_sidecar_path)
		uuid_was_generated = False
		
		if not lib_uuid:
			lib_uuid = generate_filepath_hash(lib.filepath)  # Use renamed function
			uuid_was_generated = True
		
		# Store UUID on library datablock
		lib.id_properties_ensure()[BV_UUID_PROP] = lib_uuid		# Only push UUIDs to libraries that don't have sidecars yet
		# If a library already has a sidecar, it should manage its own UUIDs
		linked_assets = linked_assets_by_library.get(lib, [])
		new_assets = {}
		
		if not os.path.exists(lib_sidecar_path):
			# Library has no sidecar - we need to create initial sidecar with proper asset UUIDs
			# Generate UUIDs for each linked asset based on their library and name
			for asset in linked_assets:
				if asset["uuid"] is None:
					# Generate a deterministic UUID for this library asset
					# This ensures the same asset always gets the same UUID
					asset_identifier = f"{lib_uuid}:{asset['name']}:{asset['type']}"
					import hashlib
					asset_uuid = str(hashlib.md5(asset_identifier.encode()).hexdigest())
					# Format as UUID
					asset_uuid = f"{asset_uuid[:8]}-{asset_uuid[8:12]}-{asset_uuid[12:16]}-{asset_uuid[16:20]}-{asset_uuid[20:32]}"
					asset["uuid"] = asset_uuid
				
				new_assets[asset["uuid"]] = asset
		# If library already has a sidecar, don't push any UUIDs - let library manage its own
		
		# Schedule UUID push only for new libraries without sidecars
		if not os.path.exists(lib_sidecar_path) and (uuid_was_generated or new_assets):
			uuid_pushes[lib_sidecar_path] = (lib_uuid, new_assets)
		# Add to sidecar content
		vault_root = get_obsidian_vault_root()
		warning_prefix = get_resource_warning_prefix(lib_path, blend_path, vault_root)
		sections.extend([
			'#### ' + warning_prefix + format_primary_link(lib_path + SIDECAR_EXTENSION, os.path.basename(lib_path)),
			"```json",
			json.dumps({
				"path": lib_path,
				"uuid": lib_uuid,
				"assets": linked_assets
			}, indent=2, ensure_ascii=False),
			"```",
			""
		])
	
	return uuid_pushes


def _build_resources_section(sections: List[str], resources: List[dict], blend_path: str) -> None:
	"""Build the resources section with categorized subheadings."""
	sections.extend([
		"### Resources"
	])
	
	if not resources:
		sections.append("- None")
		return
	
	# Group resources by type
	resources_by_type = {}
	for resource in resources:
		resource_type = resource["type"]
		if resource_type not in resources_by_type:
			resources_by_type[resource_type] = []
		resources_by_type[resource_type].append(resource)
	
	# Define type order and display names
	type_order = ["Image", "Video", "Audio", "Text", "Cache"]
	type_display_names = {
		"Image": "Textures",
		"Video": "Videos", 
		"Audio": "Audio",
		"Text": "Scripts",
		"Cache": "Caches"
	}
	
	vault_root = get_obsidian_vault_root()
	
	# Add each resource type as a subheading
	for resource_type in type_order:
		if resource_type in resources_by_type:
			sections.extend([
				f"#### {type_display_names[resource_type]}"
			])
			
			for resource in resources_by_type[resource_type]:
				# Get warning prefix if resource is outside the vault
				warning_prefix = get_resource_warning_prefix(
					resource["path"], 
					blend_path, 
					vault_root
				)
				
				sections.append('- ' + warning_prefix + format_primary_link(resource["path"], resource["name"]))
