"""
Content building utilities for Blend Vault.
Handles building sidecar markdown content from collected data.
"""

import bpy  # type: ignore
import os
import json
from typing import Dict, List, Tuple
from utils import (
	ensure_library_hash,
	get_resource_warning_prefix,
	SIDECAR_EXTENSION,
	BV_UUID_PROP,
	BV_FILE_UUID_KEY,
	MD_PRIMARY_FORMAT
)
from preferences import get_obsidian_vault_root
from .uuid_manager import read_sidecar_uuid


def build_sidecar_content(
	blend_path: str, 
	local_assets: Dict, 
	linked_assets_by_library: Dict,
	resources: List[dict]
) -> Tuple[str, Dict]:
	"""Build sidecar content and track UUID pushes."""
	file_uuid = read_sidecar_uuid(blend_path + SIDECAR_EXTENSION) or ensure_library_hash(blend_path)
	
	# Build content sections
	sections = [
		"## %% Blend Vault Data",
		"This section is auto-generated by the Blend Vault plugin and will be overwritten on save.",
		"",
		"### Current File",
		"```json",
		json.dumps({
			"path": os.path.basename(blend_path),
			BV_FILE_UUID_KEY: file_uuid,
			"assets": list(local_assets.values())
		}, indent=2, ensure_ascii=False),
		"```",
		"",
		"### Linked Libraries"
	]
	
	# Add linked libraries section
	uuid_pushes = {}
	libraries = list(bpy.data.libraries)
	
	if not libraries:
		sections.append("- None")
	else:
		uuid_pushes = _build_linked_libraries_section(sections, libraries, blend_path, linked_assets_by_library)
	
	# Add resources section
	_build_resources_section(sections, resources, blend_path)
	
	return "\n".join(sections) + "\n", uuid_pushes


def _build_linked_libraries_section(
	sections: List[str], 
	libraries: List, 
	blend_path: str, 
	linked_assets_by_library: Dict
) -> Dict:
	"""Build the linked libraries section and return UUID pushes."""
	uuid_pushes = {}
	
	for lib in libraries:
		# Process library path
		lib_path = lib.filepath.lstrip('//').replace('\\', '/')
		lib_sidecar_path = os.path.normpath(
			os.path.join(os.path.dirname(blend_path), lib_path)
		) + SIDECAR_EXTENSION
		
		# Get or generate library UUID
		lib_uuid = read_sidecar_uuid(lib_sidecar_path)
		uuid_was_generated = False
		
		if not lib_uuid:
			lib_uuid = ensure_library_hash(lib.filepath)
			uuid_was_generated = True
		
		# Store UUID on library datablock
		lib.id_properties_ensure()[BV_UUID_PROP] = lib_uuid
		
		# Check for newly generated asset UUIDs
		linked_assets = linked_assets_by_library.get(lib, [])
		new_assets = {}
		
		if os.path.exists(lib_sidecar_path):
			try:
				with open(lib_sidecar_path, 'r', encoding='utf-8') as f:
					sidecar_content = f.read()
				new_assets = {
					asset["uuid"]: asset for asset in linked_assets 
					if asset["uuid"] not in sidecar_content
				}
			except Exception:
				new_assets = {asset["uuid"]: asset for asset in linked_assets}
		else:
			new_assets = {asset["uuid"]: asset for asset in linked_assets}
		
		# Schedule UUID push if needed
		if uuid_was_generated or new_assets:
			uuid_pushes[lib_sidecar_path] = (lib_uuid, new_assets)
		
		# Add to sidecar content
		vault_root = get_obsidian_vault_root()
		warning_prefix = get_resource_warning_prefix(lib_path, blend_path, vault_root)
		sections.extend([
			'#### ' + warning_prefix + MD_PRIMARY_FORMAT['format'].format(
				name=os.path.basename(lib_path), 
				path=lib_path
			),
			"```json",
			json.dumps({
				"path": lib_path,
				"uuid": lib_uuid,
				"assets": linked_assets
			}, indent=2, ensure_ascii=False),
			"```",
			""
		])
	
	return uuid_pushes


def _build_resources_section(sections: List[str], resources: List[dict], blend_path: str) -> None:
	"""Build the resources section with categorized subheadings."""
	sections.extend([
		"",
		"### Resources"
	])
	
	if not resources:
		sections.append("- None")
		return
	
	# Group resources by type
	resources_by_type = {}
	for resource in resources:
		resource_type = resource["type"]
		if resource_type not in resources_by_type:
			resources_by_type[resource_type] = []
		resources_by_type[resource_type].append(resource)
	
	# Define type order and display names
	type_order = ["Image", "Video", "Audio", "Text", "Cache"]
	type_display_names = {
		"Image": "Textures",
		"Video": "Videos", 
		"Audio": "Audio",
		"Text": "Scripts",
		"Cache": "Caches"
	}
	
	vault_root = get_obsidian_vault_root()
	
	# Add each resource type as a subheading
	for resource_type in type_order:
		if resource_type in resources_by_type:
			sections.extend([
				"",
				f"#### {type_display_names[resource_type]}"
			])
			
			for resource in resources_by_type[resource_type]:
				# Get warning prefix if resource is outside the vault
				warning_prefix = get_resource_warning_prefix(
					resource["path"], 
					blend_path, 
					vault_root
				)
				
				sections.append('- ' + warning_prefix + MD_PRIMARY_FORMAT['format'].format(
					name=resource["name"], 
					path=resource["path"]
				))
