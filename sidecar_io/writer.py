import bpy  # type: ignore
import os
import json
import re
from typing import Dict, List, Tuple, Optional
from utils import (
	ensure_library_hash, get_asset_sources_map, LOG_COLORS, SIDECAR_EXTENSION, 
	FRONTMATTER_TAGS, MD_LINK_FORMATS, BV_UUID_PROP, 
	BV_UUID_KEY, BV_FILE_UUID_KEY
)
from .frontmatter import generate_frontmatter_string


def _log(level: str, message: str) -> None:
	"""Simplified logging function"""
	print(f"{LOG_COLORS.get(level, '')}{message}{LOG_COLORS['RESET']}")


def _extract_uuid_from_content(content: str) -> Optional[str]:
	"""Extract UUID from sidecar content, trying both key formats"""
	for key in [BV_FILE_UUID_KEY, BV_UUID_KEY]:
		match = re.search(rf'"{key}"\s*:\s*"([^"]+)"', content)
		if match:
			return match.group(1)
	return None


def _read_sidecar_uuid(sidecar_path: str) -> Optional[str]:
	"""Read UUID from sidecar file"""
	if not os.path.exists(sidecar_path):
		return None
	
	try:
		with open(sidecar_path, 'r', encoding='utf-8') as f:
			return _extract_uuid_from_content(f.read())
	except Exception:
		return None


def _collect_assets() -> Tuple[Dict[str, dict], Dict[object, List[dict]]]:
	"""Simplified asset collection with reduced error handling"""
	local_assets = {}
	linked_assets_by_library = {}
	
	for asset_type, collection in get_asset_sources_map().items():
		if not collection:
			continue
			
		for item in collection:
			if not item:
				continue
				
			# Check if item is an asset or scene
			is_asset = asset_type == "Scene" or getattr(item, 'asset_data', None) is not None
			if not is_asset:
				continue
				
			library = getattr(item, 'library', None)
			
			# Only generate UUIDs for local assets
			if library is None:
				ensure_library_hash(item)
			
			# Collect asset info
			asset_info = {
				"name": getattr(item, 'name', f'Unnamed{asset_type}'),
				"type": asset_type,
				"uuid": ensure_library_hash(item)
			}
			
			if library is None:
				local_assets[asset_info["uuid"]] = asset_info
			else:
				linked_assets_by_library.setdefault(library, []).append(asset_info)
	
	return local_assets, linked_assets_by_library


def _build_sidecar_content(blend_path: str, local_assets: Dict, linked_assets_by_library: Dict) -> Tuple[str, Dict]:
	"""Build sidecar content and track UUID pushes"""
	file_uuid = _read_sidecar_uuid(blend_path + SIDECAR_EXTENSION) or ensure_library_hash(blend_path)
	
	# Build content sections
	sections = [
		"## %% Blend Vault Data",
		"This section is auto-generated by the Blend Vault plugin and will be overwritten on save.",
		"",
		"### Current File",
		"```json",
		json.dumps({
			"path": os.path.basename(blend_path),
			BV_FILE_UUID_KEY: file_uuid,
			"assets": list(local_assets.values())
		}, indent=2, ensure_ascii=False),
		"```",
		"",
		"### Linked Libraries"
	]
	
	uuid_pushes = {}
	libraries = list(bpy.data.libraries)
	
	if not libraries:
		sections.append("- None")
	else:
		for lib in libraries:
			# Process library path
			lib_path = lib.filepath.lstrip('//').replace('\\', '/')
			lib_sidecar_path = os.path.normpath(
				os.path.join(os.path.dirname(blend_path), lib_path)
			) + SIDECAR_EXTENSION
			
			# Get or generate library UUID
			lib_uuid = _read_sidecar_uuid(lib_sidecar_path)
			uuid_was_generated = False
			
			if not lib_uuid:
				lib_uuid = ensure_library_hash(lib.filepath)
				uuid_was_generated = True
			
			# Store UUID on library datablock
			lib.id_properties_ensure()[BV_UUID_PROP] = lib_uuid
			
			# Check for newly generated asset UUIDs
			linked_assets = linked_assets_by_library.get(lib, [])
			new_assets = {}
			
			if os.path.exists(lib_sidecar_path):
				try:
					with open(lib_sidecar_path, 'r', encoding='utf-8') as f:
						sidecar_content = f.read()
					new_assets = {
						asset["uuid"]: asset for asset in linked_assets 
						if asset["uuid"] not in sidecar_content
					}
				except Exception:
					new_assets = {asset["uuid"]: asset for asset in linked_assets}
			else:
				new_assets = {asset["uuid"]: asset for asset in linked_assets}
			
			# Schedule UUID push if needed
			if uuid_was_generated or new_assets:
				uuid_pushes[lib_sidecar_path] = (lib_uuid, new_assets)
			
			# Add to sidecar content
			sections.extend([
				MD_LINK_FORMATS['MD_ANGLE_BRACKETS']['format'].format(
					name=os.path.basename(lib_path), 
					path=lib_path
				),
				"```json",
				json.dumps({
					"path": lib_path,
					"uuid": lib_uuid,
					"assets": linked_assets
				}, indent=2, ensure_ascii=False),
				"```",
				""
			])
	
	return "\n".join(sections) + "\n", uuid_pushes


def _write_sidecar_with_content_preservation(md_path: str, new_data_content: str) -> None:
	"""Write sidecar while preserving user content"""
	original_lines = []
	if os.path.exists(md_path):
		with open(md_path, 'r', encoding='utf-8') as f:
			original_lines = f.readlines()
	
	# Generate frontmatter and extract user content
	frontmatter, fm_end_idx = generate_frontmatter_string(original_lines, FRONTMATTER_TAGS)
	user_content = ""
	
	if original_lines:
		user_lines = original_lines[fm_end_idx + 1:] if fm_end_idx != -1 else original_lines
		
		# Find and remove existing Blend Vault Data section
		blend_vault_heading = '## %% Blend Vault Data'
		for i, line in enumerate(user_lines):
			if line.strip() == blend_vault_heading:
				user_lines = user_lines[:i]
				break
		
		user_content = "".join(user_lines).strip()
	
	# Assemble final content
	content_parts = [frontmatter]
	if user_content:
		content_parts.extend([user_content, "\n\n"])
	elif frontmatter:
		content_parts.append("\n")
	
	content_parts.append(new_data_content)
	
	with open(md_path, 'w', encoding='utf-8') as f:
		f.write("".join(content_parts))


def _push_uuid_to_sidecar(sidecar_path: str, file_uuid: str, asset_updates: Dict) -> None:
	"""Simplified UUID pushing to sidecar"""
	try:
		# Read existing content
		original_lines = []
		if os.path.exists(sidecar_path):
			with open(sidecar_path, 'r', encoding='utf-8') as f:
				original_lines = f.readlines()
		
		# Extract existing assets
		existing_assets = []
		blend_vault_heading = '## %% Blend Vault Data'
		
		for i, line in enumerate(original_lines):
			if line.strip() == blend_vault_heading:
				content_after = ''.join(original_lines[i:])
				json_match = re.search(r'### Current File\s*\n```json\s*\n(.*?)\n```', content_after, re.DOTALL)
				if json_match:
					try:
						data = json.loads(json_match.group(1))
						existing_assets = data.get('assets', [])
					except json.JSONDecodeError:
						pass
				break
		
		# Merge assets
		if asset_updates:
			asset_dict = {asset.get('uuid'): asset for asset in existing_assets if asset.get('uuid')}
			asset_dict.update(asset_updates)
			existing_assets = list(asset_dict.values())
		
		# Build new content
		new_content = "\n".join([
			"## %% Blend Vault Data",
			"This section is auto-generated by the Blend Vault plugin and will be overwritten on save.",
			"",
			"### Current File",
			"```json",
			json.dumps({
				"path": os.path.basename(sidecar_path.replace(SIDECAR_EXTENSION, '')),
				BV_FILE_UUID_KEY: file_uuid,
				"assets": existing_assets
			}, indent=2, ensure_ascii=False),
			"```",
			"",
			"### Linked Libraries",
			"- None",
			""
		])
		
		_write_sidecar_with_content_preservation(sidecar_path, new_content)
		_log('SUCCESS', f"[Blend Vault] Pushed UUIDs to sidecar: {sidecar_path}")
		
	except Exception as e:
		_log('ERROR', f"[Blend Vault] Failed to push UUIDs to sidecar {sidecar_path}: {e}")


@bpy.app.handlers.persistent
def write_library_info(*args, **kwargs):
	"""Simplified main handler to write sidecar file"""
	blend_path = bpy.data.filepath
	if not blend_path:
		_log('WARN', "[Blend Vault] No blend file path found, skipping write")
		return
	
	_log('INFO', f"[Blend Vault] Writing sidecar for: {blend_path}")
	
	# Optional relink step
	try:
		from relink.asset_relinker import relink_renamed_assets
		relink_renamed_assets()
	except Exception as e:
		_log('ERROR', f"[Blend Vault] Asset relink failed: {e}")
	
	# Collect assets and build content
	local_assets, linked_assets_by_library = _collect_assets()
	sidecar_content, uuid_pushes = _build_sidecar_content(blend_path, local_assets, linked_assets_by_library)
	
	# Write main sidecar
	md_path = blend_path + SIDECAR_EXTENSION
	try:
		_write_sidecar_with_content_preservation(md_path, sidecar_content)
		_log('SUCCESS', f"[Blend Vault] Sidecar written: {md_path}")
	except Exception as e:
		_log('ERROR', f"[Blend Vault] Failed to write sidecar {md_path}: {e}")
		return
	
	# Push UUIDs to linked library sidecars
	for lib_sidecar_path, (file_uuid, asset_updates) in uuid_pushes.items():
		# Validate linked blend file exists
		linked_blend_path = lib_sidecar_path[:-len(SIDECAR_EXTENSION)]
		if os.path.exists(linked_blend_path) and (asset_updates or file_uuid):
			_push_uuid_to_sidecar(lib_sidecar_path, file_uuid, asset_updates)
		elif not os.path.exists(linked_blend_path):
			_log('WARN', f"[Blend Vault] Skipping push to {lib_sidecar_path} - linked blend file missing")


write_library_info.persistent = True
